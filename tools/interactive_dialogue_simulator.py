#!/usr/bin/env python3
"""
Interactive Dialogue Simulator

This script provides an interactive, wizard-style simulation environment for:
1. Multi-turn dialogue between client and requirements analyst
2. Loading existing conversations or starting new ones
3. Sending user_message_raw events to the event bus
4. Environment checks to ensure Redis server is running

Usage:
    python tools/interactive_dialogue_simulator.py
    
Input Formats:
    ÂÆ¢Êà∑: <message>     - Client message (sent to event bus)
    ÂàÜÊûêÂ∏à: <message>   - Analyst message (stored locally)
    C: <message>       - Client message (short form)
    A: <message>       - Analyst message (short form)
    > <message>        - Client message (symbol form)
    < <message>        - Analyst message (symbol form)
    
Special Commands:
    quit              - Exit the dialogue
    history           - Show full conversation history
    save <name>       - Save conversation with given name
    help              - Show input format help
"""

import os
import sys
import json
import uuid
import time
import redis
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, UTC
from pathlib import Path

# Add the project root to the path so we can import our modules
sys.path.insert(0, os.path.join(os.path.dirname(__file__), '..'))

try:
    from event_bus_framework import create_event_bus, get_service_config
    from event_bus_framework.core.interfaces import IEventBus
except ImportError as e:
    print(f"Error importing event bus framework: {e}")
    print("Please ensure you're running from the project root and the event bus framework is installed.")
    sys.exit(1)


class DialogueSimulator:
    """Interactive dialogue simulator with event bus integration"""
    
    def __init__(self):
        self.event_bus: Optional[IEventBus] = None
        self.conversations_dir = Path("tools/conversations")
        self.conversations_dir.mkdir(exist_ok=True)
        self.current_conversation: List[Dict[str, Any]] = []
        self.current_session_id: str = ""
        self.current_channel_id: str = ""
        
    def check_environment(self) -> bool:
        """Check if Redis server is running and accessible"""
        print("üîç Checking environment...")
        
        # First check if Redis is running via Docker
        if self._check_redis_docker():
            return True
        
        # Then check if Redis is running locally
        if self._check_redis_local():
            return True
        
        # If neither worked, try to start Redis via Docker
        print("‚ö†Ô∏è Redis not found, attempting to start via Docker...")
        if self._start_redis_docker():
            return True
        
        print("‚ùå Could not start or connect to Redis")
        print("Please ensure Redis is running either:")
        print("  1. Via Docker: docker run -d -p 6379:6379 redis:alpine")
        print("  2. Locally: sudo systemctl start redis-server")
        print("  3. Via docker-compose: docker-compose up -d redis")
        return False
    
    def _check_redis_docker(self) -> bool:
        """Check if Redis is running in Docker container"""
        try:
            import subprocess
            result = subprocess.run(['docker', 'ps', '--filter', 'ancestor=redis', '--format', '{{.Names}}'], 
                                  capture_output=True, text=True, timeout=10)
            
            if result.returncode == 0 and result.stdout.strip():
                print("üì¶ Found Redis running in Docker container")
                # Try to connect to it
                redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
                redis_client.ping()
                print("‚úÖ Redis Docker container is accessible")
                return True
        except subprocess.TimeoutExpired:
            print("‚è∞ Docker command timed out")
        except subprocess.CalledProcessError:
            print("üîç Docker not available or no Redis containers found")
        except redis.ConnectionError:
            print("üì¶ Redis container found but not accessible on localhost:6379")
        except Exception as e:
            print(f"üîç Error checking Docker Redis: {e}")
        
        return False
    
    def _check_redis_local(self) -> bool:
        """Check if Redis is running locally"""
        try:
            redis_client = redis.Redis(host='localhost', port=6379, decode_responses=True)
            redis_client.ping()
            print("‚úÖ Local Redis server is running and accessible")
            return True
        except redis.ConnectionError:
            print("üîç Local Redis server not accessible")
        except Exception as e:
            print(f"üîç Error checking local Redis: {e}")
        
        return False
    
    def _start_redis_docker(self) -> bool:
        """Attempt to start Redis via Docker"""
        try:
            import subprocess
            print("üöÄ Starting Redis container...")
            
            # Check if docker is available
            result = subprocess.run(['docker', '--version'], capture_output=True, timeout=5)
            if result.returncode != 0:
                print("‚ùå Docker is not available")
                return False
            
            # Start Redis container
            result = subprocess.run([
                'docker', 'run', '-d', 
                '--name', 'redis-dialogue-sim',
                '-p', '6379:6379',
                'redis:alpine'
            ], capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                print("üéâ Redis container started successfully")
                # Wait a moment for Redis to start
                time.sleep(2)
                # Test connection
                return self._check_redis_local()
            else:
                # Container might already exist, try to start existing one
                result = subprocess.run([
                    'docker', 'start', 'redis-dialogue-sim'
                ], capture_output=True, text=True, timeout=15)
                
                if result.returncode == 0:
                    print("üéâ Existing Redis container started successfully")
                    time.sleep(2)
                    return self._check_redis_local()
                else:
                    print(f"‚ùå Failed to start Redis container: {result.stderr}")
                    return False
                    
        except subprocess.TimeoutExpired:
            print("‚è∞ Docker command timed out")
        except FileNotFoundError:
            print("‚ùå Docker command not found")
        except Exception as e:
            print(f"‚ùå Error starting Redis Docker container: {e}")
        
        return False
    
    def initialize_event_bus(self) -> bool:
        """Initialize the event bus connection"""
        try:
            print("üîó Initializing event bus connection...")
            
            # Load event bus configuration
            event_bus_config = get_service_config('event_bus')
            if not event_bus_config:
                print("‚ùå No event bus configuration found")
                print("Please ensure config/event_bus.yml exists and is properly configured")
                return False
            
            # Modify Redis host for local development if needed
            redis_config = event_bus_config.get('redis', {})
            if redis_config.get('host') == 'redis':
                # For local development, connect to localhost instead of container name
                redis_config = redis_config.copy()
                redis_config['host'] = 'localhost'
                event_bus_config = event_bus_config.copy()
                event_bus_config['redis'] = redis_config
            
            # Create event bus
            self.event_bus = create_event_bus(
                config=event_bus_config,
                service_name="dialogue_simulator"
            )
            
            print("‚úÖ Event bus initialized successfully")
            return True
            
        except Exception as e:
            print(f"‚ùå Error initializing event bus: {e}")
            return False
    
    def list_existing_conversations(self) -> List[str]:
        """List all existing conversation files"""
        conversations = []
        for file_path in self.conversations_dir.glob("*.json"):
            conversations.append(file_path.stem)
        return sorted(conversations)
    
    def load_conversation(self, conversation_name: str) -> bool:
        """Load an existing conversation"""
        try:
            file_path = self.conversations_dir / f"{conversation_name}.json"
            if not file_path.exists():
                print(f"‚ùå Conversation '{conversation_name}' not found")
                return False
            
            with open(file_path, 'r', encoding='utf-8') as f:
                data = json.load(f)
                self.current_conversation = data.get('messages', [])
                self.current_session_id = data.get('session_id', str(uuid.uuid4()))
                self.current_channel_id = data.get('channel_id', f"ecommerce_dev")
            
            print(f"‚úÖ Loaded conversation '{conversation_name}' with {len(self.current_conversation)} messages")
            return True
            
        except Exception as e:
            print(f"‚ùå Error loading conversation: {e}")
            return False
    
    def save_conversation(self, conversation_name: str) -> bool:
        """Save the current conversation"""
        try:
            file_path = self.conversations_dir / f"{conversation_name}.json"
            data = {
                'session_id': self.current_session_id,
                'channel_id': self.current_channel_id,
                'created_at': datetime.now(UTC).isoformat(),
                'messages': self.current_conversation
            }
            
            with open(file_path, 'w', encoding='utf-8') as f:
                json.dump(data, f, indent=2, ensure_ascii=False)
            
            print(f"‚úÖ Conversation saved as '{conversation_name}'")
            return True
            
        except Exception as e:
            print(f"‚ùå Error saving conversation: {e}")
            return False
    
    def start_new_conversation(self):
        """Start a new conversation"""
        self.current_conversation = []
        self.current_session_id = str(uuid.uuid4())
        self.current_channel_id = f"ecommerce_dev"
        print(f"üÜï Started new conversation")
        print(f"   Session ID: {self.current_session_id}")
        print(f"   Channel ID: {self.current_channel_id}")
    
    def display_conversation_history(self):
        """Display the current conversation history"""
        if not self.current_conversation:
            print("üìù No messages in current conversation")
            return
        
        print("\nüìù Conversation History:")
        print("=" * 60)
        for i, msg in enumerate(self.current_conversation, 1):
            speaker = "üë§ ÂÆ¢Êà∑" if msg['speaker_type'] == 'client' else "ü§ñ ÈúÄÊ±ÇÂàÜÊûêÂ∏à"
            timestamp = msg.get('timestamp', 'Unknown time')
            text = msg.get('text', '')
            print(f"{i:2d}. [{timestamp}] {speaker}")
            print(f"    {text}")
            print()
    
    def display_recent_conversation(self, count: int = 5):
        """Display recent conversation turns in compact format"""
        if not self.current_conversation:
            return
        
        recent_messages = self.current_conversation[-count:] if len(self.current_conversation) > count else self.current_conversation
        
        if recent_messages:
            print(f"\nüìù ÊúÄËøë {len(recent_messages)} ËΩÆÂØπËØù:")
            print("-" * 50)
            for i, msg in enumerate(recent_messages, len(self.current_conversation) - len(recent_messages) + 1):
                speaker_icon = "üë§" if msg['speaker_type'] == 'client' else "ü§ñ"
                speaker_name = "ÂÆ¢Êà∑" if msg['speaker_type'] == 'client' else "ÂàÜÊûêÂ∏à"
                text = msg.get('text', '')
                
                # Êà™Êñ≠ÈïøÊñáÊú¨
                if len(text) > 80:
                    text = text[:77] + "..."
                
                print(f"{i:2d}. {speaker_icon} {speaker_name}: {text}")
            print()
    
    def show_input_help(self):
        """Show help for input formats"""
        print("\nüí° ËæìÂÖ•Ê†ºÂºèÂ∏ÆÂä©:")
        print("=" * 50)
        print("üßë‚Äçüíº ÂÆ¢Êà∑Ê∂àÊÅØ (‰ºöÂèëÈÄÅÂà∞‰∫ã‰ª∂ÊÄªÁ∫ø):")
        print("   ÂÆ¢Êà∑: <Ê∂àÊÅØÂÜÖÂÆπ>")
        print("   C: <Ê∂àÊÅØÂÜÖÂÆπ>")
        print("   > <Ê∂àÊÅØÂÜÖÂÆπ>")
        print()
        print("ü§ñ ÈúÄÊ±ÇÂàÜÊûêÂ∏àÊ∂àÊÅØ (‰ªÖ‰øùÂ≠òÂà∞Êú¨Âú∞):")
        print("   ÂàÜÊûêÂ∏à: <Ê∂àÊÅØÂÜÖÂÆπ>")
        print("   A: <Ê∂àÊÅØÂÜÖÂÆπ>")
        print("   < <Ê∂àÊÅØÂÜÖÂÆπ>")
        print()
        print("üîß ÁâπÊÆäÂëΩ‰ª§:")
        print("   quit           - ÈÄÄÂá∫ÂØπËØù")
        print("   history        - ÊòæÁ§∫ÂÆåÊï¥ÂØπËØùÂéÜÂè≤")
        print("   save <ÂêçÁß∞>    - ‰øùÂ≠òÂØπËØù")
        print("   help           - ÊòæÁ§∫Ê≠§Â∏ÆÂä©")
        print("=" * 50)
    
    def parse_input_message(self, user_input: str) -> Optional[Tuple[str, str]]:
        """
        Parse user input to extract speaker type and message
        Returns: (speaker_type, message) or None if invalid/special command
        """
        user_input = user_input.strip()
        
        # Handle special commands
        if user_input.lower() == 'quit':
            return None
        elif user_input.lower() == 'history':
            self.display_conversation_history()
            return self.parse_input_message(input("\nüí¨ ËØ∑ËæìÂÖ•Ê∂àÊÅØ: "))
        elif user_input.lower().startswith('save '):
            name = user_input[5:].strip()
            if name:
                self.save_conversation(name)
            else:
                print("‚ùå ËØ∑Êèê‰æõ‰øùÂ≠òÂêçÁß∞Ôºå‰æãÂ¶Ç: save ÂØπËØù1")
            return self.parse_input_message(input("\nüí¨ ËØ∑ËæìÂÖ•Ê∂àÊÅØ: "))
        elif user_input.lower() == 'help':
            self.show_input_help()
            return self.parse_input_message(input("\nüí¨ ËØ∑ËæìÂÖ•Ê∂àÊÅØ: "))
        
        # Parse message with prefixes
        if user_input.startswith('ÂÆ¢Êà∑:') or user_input.startswith('ÂÆ¢Êà∑Ôºö'):
            message = user_input[3:].strip()
            return ('client', message) if message else None
        elif user_input.startswith('ÂàÜÊûêÂ∏à:') or user_input.startswith('ÂàÜÊûêÂ∏àÔºö'):
            message = user_input[4:].strip()
            return ('analyst', message) if message else None
        elif user_input.startswith('C:') or user_input.startswith('CÔºö'):
            message = user_input[2:].strip()
            return ('client', message) if message else None
        elif user_input.startswith('A:') or user_input.startswith('AÔºö'):
            message = user_input[2:].strip()
            return ('analyst', message) if message else None
        elif user_input.startswith('> '):
            message = user_input[2:].strip()
            return ('client', message) if message else None
        elif user_input.startswith('< '):
            message = user_input[2:].strip()
            return ('analyst', message) if message else None
        else:
            print("‚ùå Êó†ÊïàËæìÂÖ•Ê†ºÂºèÔºÅËØ∑‰ΩøÁî®‰ª•‰∏ãÊ†ºÂºè‰πã‰∏Ä:")
            print("   ÂÆ¢Êà∑: <Ê∂àÊÅØ>  Êàñ  C: <Ê∂àÊÅØ>  Êàñ  > <Ê∂àÊÅØ>")
            print("   ÂàÜÊûêÂ∏à: <Ê∂àÊÅØ>  Êàñ  A: <Ê∂àÊÅØ>  Êàñ  < <Ê∂àÊÅØ>")
            print("   ËæìÂÖ• 'help' Êü•ÁúãËØ¶ÁªÜÂ∏ÆÂä©")
            return self.parse_input_message(input("\nüí¨ ËØ∑ËæìÂÖ•Ê∂àÊÅØ: "))
    
    def create_user_message_raw_event(self, text: str, speaker_type: str) -> Dict[str, Any]:
        """Create a user_message_raw event following the events.yml schema"""
        # For client messages, we send to event bus; for analyst messages, we just store
        timestamp_ms = int(time.time() * 1000)
        
        return {
            "meta": {
                "event_id": str(uuid.uuid4()),
                "source": "dialogue_simulator",
                "timestamp": timestamp_ms
            },
            "user_id": f"{speaker_type}_user_{int(time.time())}",
            "username": "ÂÆ¢Êà∑" if speaker_type == 'client' else "ÈúÄÊ±ÇÂàÜÊûêÂ∏à",
            "platform": "dialogue_simulator",
            "channel_id": self.current_channel_id,
            "content": {
                "text": text,
                "attachments": None
            },
            "raw_data": {
                "speaker_type": speaker_type,
                "session_id": self.current_session_id
            }
        }
    
    def send_event_to_bus(self, event_data: Dict[str, Any]) -> bool:
        """Send user_message_raw event to the event bus"""
        try:
            if not self.event_bus:
                print("‚ùå Event bus not initialized")
                return False
            
            topic = "user_message_raw"
            message_id = self.event_bus.publish(topic, event_data)
            
            if message_id:
                print(f"‚úÖ Event sent to bus with ID: {message_id}")
                return True
            else:
                print("‚ùå Failed to send event to bus")
                return False
                
        except Exception as e:
            print(f"‚ùå Error sending event to bus: {e}")
            return False
    
    def add_message_to_conversation(self, text: str, speaker_type: str):
        """Add a message to the current conversation"""
        message = {
            "timestamp": datetime.now(UTC).isoformat(),
            "speaker_type": speaker_type,
            "text": text,
            "event_sent": speaker_type == 'client'  # Only client messages are sent as events
        }
        self.current_conversation.append(message)
    
    def choose_conversation_mode(self) -> str:
        """Let user choose between new conversation or loading existing one"""
        existing_conversations = self.list_existing_conversations()
        
        print("\nüìã ÈÄâÊã©ÂØπËØùÊ®°Âºè:")
        print("1. ÂºÄÂßãÊñ∞ÂØπËØù")
        
        if existing_conversations:
            print("2. ÁªßÁª≠Â∑≤ÊúâÂØπËØù")
            print("\nÂ∑≤ÊúâÂØπËØù:")
            for i, conv in enumerate(existing_conversations, 1):
                print(f"   {i}. {conv}")
        
        while True:
            choice = input("\nËØ∑ÈÄâÊã© (1 ÂºÄÂßãÊñ∞ÂØπËØù, 2 ÁªßÁª≠Â∑≤ÊúâÂØπËØù): ").strip()
            
            if choice == '1':
                return 'new'
            elif choice == '2' and existing_conversations:
                return 'existing'
            else:
                print("‚ùå Êó†ÊïàÈÄâÊã©")
    
    def choose_existing_conversation(self) -> Optional[str]:
        """Let user choose from existing conversations"""
        existing_conversations = self.list_existing_conversations()
        
        if not existing_conversations:
            print("‚ùå Ê≤°ÊúâÂ∑≤ÊúâÂØπËØù")
            return None
        
        print("\nÈÄâÊã©Ë¶ÅÁªßÁª≠ÁöÑÂØπËØù:")
        for i, conv in enumerate(existing_conversations, 1):
            print(f"{i}. {conv}")
        
        while True:
            try:
                choice = input(f"ËØ∑ËæìÂÖ•ÁºñÂè∑ (1-{len(existing_conversations)}): ").strip()
                index = int(choice) - 1
                
                if 0 <= index < len(existing_conversations):
                    return existing_conversations[index]
                else:
                    print(f"‚ùå ËØ∑ËæìÂÖ• 1 Âà∞ {len(existing_conversations)} ‰πãÈó¥ÁöÑÊï∞Â≠ó")
            except ValueError:
                print("‚ùå ËØ∑ËæìÂÖ•ÊúâÊïàÊï∞Â≠ó")
    
    def run_dialogue_loop(self):
        """Main dialogue loop"""
        print("\nüéØ ÂºÄÂßãÂØπËØù‰ªøÁúü...")
        print("ËæìÂÖ•Ê†ºÂºè: ÂÆ¢Êà∑: <Ê∂àÊÅØ> Êàñ ÂàÜÊûêÂ∏à: <Ê∂àÊÅØ> (ËæìÂÖ• 'help' Êü•ÁúãËØ¶ÁªÜÂ∏ÆÂä©)")
        print("ÂÆ¢Êà∑Ê∂àÊÅØÂ∞Ü‰Ωú‰∏∫ user_message_raw ‰∫ã‰ª∂ÂèëÈÄÅÂà∞‰∫ã‰ª∂ÊÄªÁ∫ø")
        print("ÈúÄÊ±ÇÂàÜÊûêÂ∏àÊ∂àÊÅØ‰ªÖ‰øùÂ≠òÂà∞ÂØπËØùÂéÜÂè≤‰∏≠")
        
        while True:
            # Get user input with new streamlined format
            user_input = input("\nüí¨ ËØ∑ËæìÂÖ•Ê∂àÊÅØ: ").strip()
            
            # Parse the input
            result = self.parse_input_message(user_input)
            if result is None:  # User chose to quit or invalid input was handled
                break
            
            speaker_type, text = result
            
            # Add to conversation history
            self.add_message_to_conversation(text, speaker_type)
            
            # If it's a client message, send as event to bus
            if speaker_type == 'client':
                event_data = self.create_user_message_raw_event(text, speaker_type)
                success = self.send_event_to_bus(event_data)
                if success:
                    print("üì® ÂÆ¢Êà∑Ê∂àÊÅØÂ∑≤ÂèëÈÄÅÂà∞‰∫ã‰ª∂ÊÄªÁ∫øÔºåÁ≠âÂæÖ NLU ÊúçÂä°Â§ÑÁêÜ...")
                else:
                    print("‚ö†Ô∏è ÂÆ¢Êà∑Ê∂àÊÅØÂèëÈÄÅÂ§±Ë¥•Ôºå‰ΩÜÂ∑≤‰øùÂ≠òÂà∞ÂØπËØùÂéÜÂè≤")
            else:
                print("üìù ÈúÄÊ±ÇÂàÜÊûêÂ∏àÊ∂àÊÅØÂ∑≤‰øùÂ≠òÂà∞ÂØπËØùÂéÜÂè≤")
            
            # Display recent conversation after each message
            self.display_recent_conversation(3)
            
            print(f"üìä ÂΩìÂâçÂØπËØùÂåÖÂê´ {len(self.current_conversation)} Êù°Ê∂àÊÅØ")
    
    def run(self):
        """Main entry point"""
        print("üé≠ ‰∫§‰∫íÂºèÂØπËØù‰ªøÁúüÂô®")
        print("=" * 50)
        
        # Environment check
        if not self.check_environment():
            return
        
        # Initialize event bus
        if not self.initialize_event_bus():
            return
        
        # Choose conversation mode
        mode = self.choose_conversation_mode()
        
        if mode == 'new':
            self.start_new_conversation()
        elif mode == 'existing':
            conv_name = self.choose_existing_conversation()
            if conv_name and not self.load_conversation(conv_name):
                print("ÂàáÊç¢Âà∞Êñ∞ÂØπËØùÊ®°Âºè")
                self.start_new_conversation()
        
        # Display current conversation if any
        if self.current_conversation:
            self.display_conversation_history()
        
        # Show input help
        self.show_input_help()
        
        # Run main dialogue loop
        self.run_dialogue_loop()
        
        # Save conversation on exit
        if self.current_conversation:
            save_choice = input("\nüíæ ÊòØÂê¶‰øùÂ≠òÂΩìÂâçÂØπËØù? (y/n): ").strip().lower()
            if save_choice == 'y':
                name = input("ËØ∑ËæìÂÖ•ÂØπËØùÂêçÁß∞: ").strip()
                if name:
                    self.save_conversation(name)
        
        print("\nüëã ÂØπËØù‰ªøÁúüÁªìÊùüÔºÅ")


def main():
    """Main function"""
    try:
        simulator = DialogueSimulator()
        simulator.run()
    except KeyboardInterrupt:
        print("\n\n‚ö†Ô∏è Áî®Êà∑‰∏≠Êñ≠ÔºåÁ®ãÂ∫èÈÄÄÂá∫")
    except Exception as e:
        print(f"\n‚ùå Á®ãÂ∫èÂºÇÂ∏∏: {e}")
        import traceback
        traceback.print_exc()


if __name__ == "__main__":
    main() 